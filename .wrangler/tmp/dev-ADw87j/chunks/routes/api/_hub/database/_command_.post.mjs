import{e as a,a as r,g as e,j as t}from"../../../../runtime.mjs";import{z as s}from"../../../../_/index.mjs";import{h as m}from"../../../../_/database.mjs";import{r as n}from"../../../../_/auth.mjs";const i=s.object({query:s.string().min(1).max(1e6).trim(),params:s.any().array().default([])}),o=a((async a=>{await n(a),r("database");const{command:o}=await e(a,s.object({command:s.enum(["first","all","raw","run","dump","exec","batch"])}).parse),p=m();if("exec"===o){const{query:r}=await t(a,i.pick({query:!0}).parse);return p.exec(r)}if("dump"===o)return p.dump();if("first"===o){const{query:r,params:e,colName:m}=await t(a,s.intersection(i,s.object({colName:s.string().optional()})).parse);return m?p.prepare(r).bind(...e).first(m):p.prepare(r).bind(...e).first()}if("batch"===o){const r=await t(a,s.array(i).parse);return p.batch(r.map((a=>p.prepare(a.query).bind(...a.params))))}if("raw"===o){const{query:r,params:e,columnNames:m}=await t(a,s.intersection(i,s.object({columnNames:s.boolean().default(!1)})).parse);return p.prepare(r).bind(...e).raw({columnNames:m})}const{query:c,params:u}=await t(a,i.parse);return p.prepare(c).bind(...u)[o]()}));export{o as default};
//# sourceMappingURL=_command_.post.mjs.map
